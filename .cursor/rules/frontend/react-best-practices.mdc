---
description: "USE WHEN: Designing React components, implementing hooks, and managing component lifecycles."
globs: "src/components/**/*.{ts,tsx},src/hooks/**/*.{ts,tsx}"
alwaysApply: false
---

# React Best Practices

## Constraints

- **SRP:** Keep components small (max 150 lines).
- **Composition:** Use `children` or `slots` instead of prop drilling.
- **Naming:** Use `PascalCase` for components, `useCamelCase` for hooks.
- **Hooks:** Move business logic to custom hooks.
- **State:** Lift state to the nearest common ancestor.
- **Updates:** Use `setState(prev => ...)` for state updates.
- **Effects:** Use `useEffect` as a last resort. Prefer event handlers or `useMemo`.
- **Keys:** Use stable IDs for lists (index is forbidden).

## Bans

- Prop drilling (>2 levels).
- Class components.
- Incomplete dependency arrays.
- Syncing props to state (use Derived state).
- Heavy computations during render.
- Data fetching inside components (violation of API rules).

## Correct Implementation

<example>
```tsx
const stableHandler = useEvent(handler);
useEffect(() => { stableHandler(data); }, [data]);
```
</example>

## Incorrect Implementation

<incorrect-example>
```tsx
useEffect(() => { fetchData(); }, []); // Fetching forbidden
useEffect(() => { setVal(props.val); }, [props.val]); // Sync forbidden
```
</incorrect-example>
